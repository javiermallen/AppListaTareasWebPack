{"version":3,"sources":["webpack://app-lista-tareas/webpack/bootstrap","webpack://app-lista-tareas/webpack/runtime/define property getters","webpack://app-lista-tareas/webpack/runtime/hasOwnProperty shorthand","webpack://app-lista-tareas/./src/classes/tarea.class.js","webpack://app-lista-tareas/./src/js/components.js","webpack://app-lista-tareas/./src/index.js","webpack://app-lista-tareas/./src/classes/listatareas.class.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Tarea","constructor","tarea","this","id","Date","getTime","completado","fecha","nuevaTarea","document","querySelector","ul","borrarCompletados","filtros","filtrosMarco","querySelectorAll","footer","numeroTareasPend","anadirTareaHTML","tareaHTML","innerHTML","mostrarFooter","listaTareas","length","classList","remove","add","mostrarPendientes","contarPendientes","filter","textContent","mostrarBorrarCompletadas","addEventListener","evento","value","trim","nuevaTareaCreada","anadirTarea","nombreElemento","target","localName","tareaSeleccionada","parentElement","tareaId","dataset","marcarCompletado","toggle","eliminarTarea","removeChild","eliminarCompletados","index","children","elemento","contains","forEach","filtro","textoFiltroSeleccionado","text","etiquetaSeleccionada","console","log","setAttribute","textoLabel","removeAttribute","guardarLocalStorage","cargarLocalStorage","push","localStorage","setItem","JSON","stringify","getItem","parse"],"mappings":"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","file":"bundle.59bea90e462f09d0d340.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","//Vamos a tener una clase que es la tarea, es esta recibira una tarea nueva y a partir de ahí creara una serie de datos\r\nexport class Tarea {\r\n    constructor( tarea ) {\r\n        this.tarea = tarea;\r\n\r\n        //Necesitaremos un identificador único para cada tarea\r\n        this.id = new Date().getTime();\r\n        //Necesitamos saber si las tareas están completas o no\r\n        this.completado = false;\r\n        this.fecha = new Date();\r\n    }\r\n}\r\n","import { Tarea } from '../classes/index';\r\nimport { listaTareas } from '../index';\r\n\r\n//variables cogidas del DOMHTML\r\n//Cojo el input donde escribimos las tareas\r\nconst nuevaTarea        = document.querySelector( '.new-todo' );\r\n//Cojo el padre de las li, que es el elemento ul\r\nconst ul                = document.querySelector( '.todo-list' );\r\n//Cojo el botón de eliminar completados del HTML\r\nconst borrarCompletados = document.querySelector( '.clear-completed' );\r\n//Cojo la lista donde se encuentran los botones que realizan los filtos\r\nconst filtros           = document.querySelector( '.filters' );\r\n//Cojo cada uno de los filtros para poder recorrer el vector\r\nconst filtrosMarco      = document.querySelectorAll( '.filtro' );\r\n//Cojo el footer para ocultarlo cuando no hay ninguna tarea\r\nconst footer            = document.querySelector( '.footer' );\r\n//Cojo el strong donde se muestran el número de tareas pendientes.\r\nlet numeroTareasPend    = document.querySelector( 'strong' );\r\n\r\n//Funciones\r\n//Función que sirve para que cuando escribamos una tarea se renderize en el HTML\r\nexport const anadirTareaHTML = ( tarea ) =>{\r\n\r\n    const tareaHTML = `\r\n        <li class=\"${ ( tarea.completado ) ? 'completed' : '' }\" data-id=\"${ tarea.id }\">\r\n            <div class=\"view\">\r\n                <input class=\"toggle\" type=\"checkbox\" ${ (tarea.completado) ? 'checked': '' }>\r\n                <label>${ tarea.tarea }</label>\r\n                <button class=\"destroy\"></button>\r\n            </div>\r\n                <input class=\"edit\" value=\"Create a TodoMVC template\">\r\n        </li>\r\n    `\r\n    ul.innerHTML += tareaHTML;\r\n}\r\n\r\n//Función que muestra y oculta el footer en función de si hay tareas o no\r\nexport const mostrarFooter = () => {\r\n    //Si hay algo en la lista de Tareas lo muestas y si no lo ocultas\r\n    ( listaTareas.listaTareas.length !== 0 ) ? (footer.classList.remove( 'hidden' )) : (footer.classList.add( 'hidden' ) );\r\n}\r\n//Función que muestra número de elementos pendientes en un span dentro del footer\r\nexport const mostrarPendientes = () => {\r\n    const contarPendientes = listaTareas.listaTareas.filter( ( tarea ) => tarea.completado === false );\r\n    numeroTareasPend.textContent = contarPendientes.length;\r\n}\r\n//Función que muestra el botón de eliminar completadas cuando hay tareas ya hechas\r\nexport const mostrarBorrarCompletadas = () => {\r\n    const hayCompletadas = listaTareas.listaTareas.filter( ( tarea ) => tarea.completado === true );\r\n    ( hayCompletadas.length > 0 ) ? ( borrarCompletados.classList.remove( 'hidden' ) ) : ( borrarCompletados.classList.add( 'hidden' ));\r\n}\r\n\r\n\r\n//Eventos\r\n//Evento que al pulsar la tecla enter crea la tarea, añade la tarea al HTML y la añade a la lista de tareas.\r\nnuevaTarea.addEventListener( 'keyup', ( evento ) => {\r\n    //https://keycode.info/\r\n    //Hacemos una condición que será si pulsa la tecla Enter y si hay contenido dentro del cuadro de tipo texto.  Le añadimos el método trim para\r\n    //eliminar los espacios al inicio uy al final.\r\n    if( evento.key === 'Enter' && nuevaTarea.value.trim().length > 0 ){\r\n        //Creo una nueva instancia a la clase tarea\r\n        const nuevaTareaCreada = new Tarea( nuevaTarea.value );\r\n        //Añadimos la nueva tarea al vector\r\n        listaTareas.anadirTarea( nuevaTareaCreada );\r\n        //Añadimos la tarea al HTML\r\n        anadirTareaHTML( nuevaTareaCreada );\r\n        //Borramos el contenido del input de texto\r\n        nuevaTarea.value = '';\r\n    }\r\n    mostrarFooter();\r\n    mostrarPendientes();\r\n    mostrarBorrarCompletadas();\r\n})\r\n//Evento que al marca los elementos como completados y da funcionalidad al botón de borrar\r\nul.addEventListener( 'click', ( evento ) => {\r\n    //Hacemos click en una de las partes del texto y tenemos que saber donde pulsamos, tenemos una propiedad en el target que se llama\r\n    //localName que nos va a decir donde pulsamos, podremos pulsar en el el checkbox, en el label o en el botón de eliminar, pues tendremos que hacer\r\n    //condiciones según donde pulsemos.\r\n    const nombreElemento    = evento.target.localName;\r\n    //Tengo que coger la li donde hago clic para que cuando pulsemos el botón de eliminar borre toda la tarea\r\n    const tareaSeleccionada = evento.target.parentElement.parentElement;\r\n    //Cojo el id único de cada una de las tareas, este id esta en el atributo de HTML data-id\r\n    const tareaId           = tareaSeleccionada.dataset.id;\r\n    //const tareaId = tareaSeleccionada.getAttribute( 'data-id' );\r\n\r\n    //Una vez que tenemos toda la información haremos un condicional, si se pulsa en el check se llama al método marcarCompletado y si \r\n    //se pulsa el botón de eliminar se llama al método de eliminar tarea\r\n    if( nombreElemento === 'input' ){\r\n        listaTareas.marcarCompletado( tareaId );\r\n        //En el console vemos que va cambiando la propiedad completado pero no tacha la tarea, para hacer eso tenemos que jugar\r\n        //con las clases y añadirle y quitarle la clase completed al li\r\n        tareaSeleccionada.classList.toggle( 'completed' );        \r\n    }\r\n    if( nombreElemento === 'button' ){\r\n        listaTareas.eliminarTarea( tareaId );\r\n        ul.removeChild( tareaSeleccionada );\r\n    }\r\n    mostrarFooter();\r\n    mostrarPendientes();\r\n    mostrarBorrarCompletadas();\r\n});\r\n//Eliminar completados\r\nborrarCompletados.addEventListener( 'click', () => {\r\n    //Llamamos al método de la clase eliminarCompletados\r\n    listaTareas.eliminarCompletados();\r\n    //Recorremos la ul donde están los li, esta es un vector y con la propiedad children puedo sacar el número de elementos\r\n    //Tendremos que recorrer el vector al reves desde el último elemento al primero, porque si lo reccoremos del inicio al final\r\n    //como se borra un elemento las posiciones del vector ya no coinciden\r\n    for( let index = ul.children.length - 1; index >= 0; index-- ){\r\n        //Guardo lo que hay en cada una de las posiciones en una variable\r\n        const elemento = ul.children[ index ];\r\n        //Hago un condicional en el que le digo si contiene la clase completed, si es verdad lo elimino de la lista\r\n        if( elemento.classList.contains( 'completed' ) ){\r\n            elemento.remove();\r\n        }\r\n    }\r\n    mostrarFooter();\r\n    mostrarPendientes();\r\n    mostrarBorrarCompletadas();\r\n});\r\n\r\n//Evento para seleccionar los elementos completados y no completados\r\nfiltros.addEventListener( 'click', ( evento ) => {\r\n    //Recorremos las a y le quitamo el cuadrado cuando pulsamos en cualquier lado de la ul\r\n    filtrosMarco.forEach( ( filtro ) => filtro.classList.remove( 'selected' ) );\r\n    //Ponemos el marco en el elemento seleccionado\r\n    evento.target.classList.add( 'selected' );\r\n    //Ponemos el texto que tiene el elemento seleccionado en una variable\r\n    const textoFiltroSeleccionado = evento.target.text;\r\n    //Podríamos añadir una medida de seguridad y es que si pulso donde no hay elemento\r\n    //o sea la constante textoFiltroSeleccionado esta vacía que salga del evento\r\n    if( !textoFiltroSeleccionado ){ return }\r\n    //Tenemos que recorrer el vector donde se encuentran las li para saber cuales estan completadas y cuales no\r\n    for( const elemento of ul.children ){\r\n        //El primer paso es quitar a todos los elementos la clase hidden por que si no \r\n        //el filtro del switch se lo asigna y se quita, además nos servirá para que funcione el botón\r\n        //de Tareas ya que mostrará todas ellas\r\n        elemento.classList.remove( 'hidden' );\r\n        //Según el botón que yo pulse ocultaras la completas o las que no esten completadas\r\n        switch ( textoFiltroSeleccionado ) {\r\n            case 'Pendientes':\r\n                //Comprobamos si el elemento seleccionado tiene la clase \"completed\", si es así le asignamos\r\n                //la clase del CSS hideen que oculta los elementos con el display none\r\n                if( elemento.classList.contains( 'completed' ) ){\r\n                    elemento.classList.add( 'hidden' );\r\n                }\r\n            break;\r\n            case 'Completadas':\r\n                //Comprobamos si el elemento seleccionado no tiene la clase \"completed\", si es así le asignamos\r\n                //la clase del CSS hideen que oculta los elementos con el display none\r\n                if( !elemento.classList.contains( 'completed' ) ){\r\n                    elemento.classList.add( 'hidden' );\r\n                }\r\n            break;\r\n        }  \r\n    }\r\n});\r\n//Añado el evento que al hacer doble clic sobre una label automaticamente la pueda modificar añadiendo el\r\n//atributo contentEditable=\"true\"\r\nul.addEventListener( 'dblclick', ( evento ) => {\r\n    const nombreElemento    = evento.target.localName;\r\n    const tareaSeleccionada = evento.target.parentElement.parentElement;\r\n    const tareaId = tareaSeleccionada.dataset.id;\r\n    //Accedemos a la label que hemos pulsado y le ponemos el contenteditable = true\r\n    if(  nombreElemento === 'label' ){\r\n        const etiquetaSeleccionada = tareaSeleccionada.children[ 0 ].children[ 1 ];\r\n        console.log( etiquetaSeleccionada );\r\n        etiquetaSeleccionada.setAttribute( 'contenteditable', true ); \r\n        etiquetaSeleccionada.setAttribute( 'style', 'border: 1px solid #000' );\r\n        //Una vez que editamos la etiqueta ponemos evento para que cuando pulsemos la tecla enter deje de ser editable\r\n        etiquetaSeleccionada.addEventListener( 'keypress', ( evento ) => {\r\n            if( evento.key === 'Enter' ){\r\n                //Tenemos que coger el valor que hay dentro de la etiqueta y guardarlo en una constante para modificarlo en el vector\r\n                const textoLabel = etiquetaSeleccionada.innerHTML;\r\n                etiquetaSeleccionada.setAttribute( 'contenteditable', false );\r\n                etiquetaSeleccionada.removeAttribute( 'style' );\r\n                //Tendremos que modificar la tarea que hemos editado usando su id\r\n                listaTareas.listaTareas.forEach( ( tarea ) => {\r\n                    //Lo que hay en el atributo es texto y lo que hay en la clase es un número\r\n                    if( tarea.id == tareaId ){\r\n                        tarea.tarea = textoLabel;\r\n                        //Faltaría actualizar el local Storage\r\n                        listaTareas.guardarLocalStorage();\r\n                    \r\n                    }\r\n                } );\r\n            }\r\n        } )\r\n    } \r\n})\r\n\r\n\r\n\r\n","//Importamos el css desde la carpeta donde se encuentra\r\nimport './css/style.css';\r\n\r\n//Importamos la clase que necesitamos\r\nimport { ListaTareas } from './classes/index';\r\n\r\n//Importamos las funciones que necesita para que funciona la aplicación\r\nimport { anadirTareaHTML, mostrarFooter, mostrarPendientes, mostrarBorrarCompletadas } from './js/components';\r\n\r\n\r\n//LLamadas a las funciones\r\nexport const listaTareas = new ListaTareas();\r\n//Tengo que llamar a la función que dibuja el HTML\r\nlistaTareas.listaTareas.forEach( ( tarea ) => anadirTareaHTML( tarea ) );\r\nmostrarFooter();\r\nmostrarPendientes();\r\nmostrarBorrarCompletadas();\r\n","//Crearemos otra clase que guarde la lista de tareas y en la que se puedan realizar varios métodos, como añadir elementos, eliminar elementos, eliminar todos, etc..\r\nexport class ListaTareas {\r\n    constructor() {\r\n        //El constructor va a ser un vector en el cual se almacenan todas las tareas que se crean e inicialmente estara vacio\r\n        // this.listaTareas = [];\r\n        this.cargarLocalStorage();\r\n    }\r\n    //El primer metodo que tiene que existir es el de añadir elementos a la lista de tareas\r\n    anadirTarea( tarea ) {\r\n        this.listaTareas.push( tarea );\r\n        this.guardarLocalStorage();\r\n    }\r\n    //Otro método será el de eliminar el elemento seleccionado de la lista de Tareas\r\n    eliminarTarea( id ) {\r\n        this.listaTareas = this.listaTareas.filter( ( tarea ) => tarea.id != id );\r\n        this.guardarLocalStorage();\r\n    }\r\n    //Otro método que será el de eliminar todos los elementos que hemos completado\r\n    eliminarCompletados() {\r\n        //Filtraremos todos los elementos que no tengan this.completado = true\r\n        this.listaTareas = this.listaTareas.filter( ( tarea ) => tarea.completado === false );\r\n        this.guardarLocalStorage();\r\n    }\r\n    marcarCompletado( id ) {\r\n        //Para marcar completado tendre que recorrer el vector y comprobar cada uno de los id con el que recibiré del evento y cuando coincidan\r\n        //le tengo que cambiar el estado\r\n        for( const tarea of this.listaTareas ){\r\n            if( tarea.id == id ) {\r\n                //En tarea id voy a tener un número que es el que se crea automaticamente cuando creamos la tarea y recibiremos un id de tipo texto\r\n                //que estará guardado en el atributo data-id.\r\n                //Cuando pulso en el checbox cambiará de estado, si esta true a false y si es false a true\r\n                tarea.completado = !tarea.completado;\r\n                this.guardarLocalStorage();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    guardarLocalStorage() {\r\n        localStorage.setItem( 'tareas', JSON.stringify( this.listaTareas ));\r\n    }\r\n    cargarLocalStorage() {\r\n        //Cuando cargamos datos del local Storage tenemos dos posibilidades, si no hay nada creamos un vector\r\n        //vacio y si hay algo cargamos los datos del local.  Esto servirá para que en el constructor llamemos \r\n        //a está función\r\n        // if( localStorage.getItem( 'tareas' )){\r\n        //    this.listaTareas= JSON.parse( localStorage.getItem( 'tareas' )); \r\n        // } else {\r\n        //     this.listaTareas= [];\r\n        // }\r\n        this.listaTareas = ( localStorage.getItem( 'tareas' ) ) ? ( JSON.parse( localStorage.getItem( 'tareas' ) ) ) : ( [] );\r\n    }\r\n}"],"sourceRoot":""}